import { Injectable } from '@angular/core';
import { environment } from 'src/environments/environment';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, Subject, throwError } from 'rxjs';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import {
  ErrorResponse,
  ReportByIdResponse,
  ReportMetaData,
} from '@core/modals';
import { LOCAL_KEYS } from '@core/util/constants/constants';
import { CommonService } from './common.service';
import { catchError } from 'rxjs/operators';
import { format } from 'date-fns';

@Injectable({
  providedIn: 'root',
})
export class ReportService {
  reportUrl = environment.API_REPORT_URL;
  _isDownloading = new Subject<boolean>();

  constructor(private http: HttpClient, private cs: CommonService) {}

  getReportTypes(): Observable<any> {
    const url = this.reportUrl + '/report/types';
    return this.http.get(url);
  }

  getListOfReports(query): Observable<any> {
    const url =
      this.reportUrl +
      '/reports' +
      query +
      '&scope=' +
      localStorage.getItem('scope');
    return this.http.get(url);
  }

  getReportById(reportID): Observable<ReportByIdResponse | ErrorResponse> {
    let params = new HttpParams().set(
      'scope',
      this.cs.getLocalData(LOCAL_KEYS.SCOPE)
    );
    const url = `${this.reportUrl}/report/${reportID}`;
    return this.http
      .get<ReportByIdResponse | ErrorResponse>(url, { params })
      .pipe(
        catchError((e) => (e?.error ? throwError(e.error) : throwError(e)))
      );
  }

  createReport(body): Observable<any> {
    const url = this.reportUrl + '/report';
    return this.http.post(url, body);
  }

  convertToCSV(
    objArray: any,
    headerList: string[],
    metaData: ReportMetaData = null
  ) {
    const DELIMITER: string = ';';
    let jsonInput =
      typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
    let csvOutput = '';
    let headerRow = '';
    if (metaData) {
      const fieldName = {
        reportType: 'Title',
        scope: 'Scope',
        createdOn: 'Date of Generation',
        createdBy: 'Generated By',
      };
      for (const field in metaData)
        csvOutput += `${fieldName[field]}${DELIMITER}${metaData[field]}\r\n`;
      csvOutput += `\r\n\r\n`;
    }

    for (let index in headerList) {
      headerRow += headerList[index] + DELIMITER;
    }
    headerRow = headerRow.slice(0, -1);
    csvOutput += headerRow + '\r\n';
    for (let i = 0; i < jsonInput.length; i++) {
      let contentLine = '';
      for (let index in headerList) {
        let head = headerList[index];
        if (index == '0') {
          contentLine += jsonInput[i][head];
        } else {
          contentLine += DELIMITER + jsonInput[i][head];
        }
      }
      csvOutput += contentLine + '\r\n';
    }
    return csvOutput;
  }

  downloadFile(
    data,
    headerList,
    filename,
    formatType,
    metaData: ReportMetaData = null
  ) {
    if (formatType == 'CSV') {
      let csvData = this.convertToCSV(data, headerList, metaData);
      let blob = new Blob(['\ufeff' + csvData], {
        type: 'text/csv;charset=utf-8;',
      });
      let dwldLink = document.createElement('a');
      let url = URL.createObjectURL(blob);
      dwldLink.setAttribute('href', url);
      dwldLink.setAttribute('download', filename + '.csv');
      dwldLink.style.visibility = 'hidden';
      document.body.appendChild(dwldLink);
      dwldLink.click();
      document.body.removeChild(dwldLink);
      this._isDownloading.next(true);
    } else if (formatType == 'PDF') {
      var doc = new jsPDF({ orientation: 'landscape' });
      if (metaData) {
        doc.setFontSize(8);
        doc.text(`Title: ${metaData.reportType}`, 15, 20);
        doc.text(`Scope: ${metaData.scope}`, 15, 25);
        doc.text(`Date of Generation: ${metaData.createdOn}`, 15, 30);
        doc.text(`Generated By: ${metaData.createdBy}`, 15, 35);
      }
      var col = headerList;
      var rows = [];
      var contentBody = typeof data != 'object' ? JSON.parse(data) : data;

      for (let i = 0; i < contentBody.length; i++) {
        let contentLine = [];
        for (let index in headerList) {
          let head = headerList[index];
          contentLine.push(contentBody[i][head]);
        }
        rows.push(contentLine);
      }
      autoTable(doc, {
        head: [col],
        body: rows,
        theme: 'grid',
        margin: { top: 40 },
        styles: {
          overflow: 'linebreak',
          cellWidth: 'auto',
          minCellWidth: 14,
          fontSize: 7,
        },
      });
      doc.save(filename + '.pdf');
      this._isDownloading.next(true);
    }
  }

  getDownloadStatus() {
    return this._isDownloading.asObservable();
  }
}
