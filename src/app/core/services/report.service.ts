import { Injectable } from '@angular/core';
import { environment } from 'src/environments/environment';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, Subject, throwError } from 'rxjs';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import {
  ConvertCSVInput,
  DownloadInput,
  ErrorResponse,
  ReportByIdResponse,
  ReportMetaData,
} from '@core/modals';
import { LOCAL_KEYS } from '@core/util/constants/constants';
import { CommonService } from './common.service';
import { catchError } from 'rxjs/operators';
import { format } from 'date-fns';
import { TranslateService } from '@ngx-translate/core';
import { SheetAOAOpts, WorkBook, WorkSheet, utils, write } from 'xlsx';
import * as FileSaver from 'file-saver';
import { frenchNumber } from '@core/util/common.functions';

@Injectable({
  providedIn: 'root',
})
export class ReportService {
  reportUrl = environment.API_REPORT_URL;
  _isDownloading = new Subject<boolean>();

  constructor(
    private http: HttpClient,
    private cs: CommonService,
    private translate: TranslateService,
  ) { }

  getReportTypes(): Observable<any> {
    const url = this.reportUrl + '/report/types';
    return this.http.get(url);
  }

  getListOfReports(query): Observable<any> {
    const url =
      this.reportUrl +
      '/reports' +
      query +
      '&scope=' +
      localStorage.getItem('scope');
    return this.http.get(url);
  }

  getReportById(reportID): Observable<ReportByIdResponse | ErrorResponse> {
    let params = new HttpParams().set(
      'scope',
      this.cs.getLocalData(LOCAL_KEYS.SCOPE)
    );
    const url = `${this.reportUrl}/report/${reportID}`;
    return this.http
      .get<ReportByIdResponse | ErrorResponse>(url, { params })
      .pipe(
        catchError((e) => (e?.error ? throwError(e.error) : throwError(e)))
      );
  }

  createReport(body): Observable<any> {
    const url = this.reportUrl + '/report';
    return this.http.post(url, body);
  }

  convertToCSV({
    objArray,
    headerList,
    metaData,
    translations,
  }: ConvertCSVInput) {
    metaData = metaData || null;
    translations = translations || null;
    const DELIMITER: string = ';';
    let jsonInput =
      typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
    let csvOutput = '';
    let headerRow = '';
    if (metaData) {
      const fieldName = {
        reportType: 'Title',
        scope: 'Scope',
        editor: 'Editor',
        createdOn: 'Date of Generation',
        createdBy: 'Generated By',
      };
      for (const field in metaData) {
        if (!metaData?.[field]) continue;
        csvOutput += `${fieldName[field]}${DELIMITER}${metaData[field]}\r\n`;
      }
      csvOutput += `\r\n\r\n`;
    }

    for (let index in headerList) {
      headerRow += translations?.[headerList[index]]
        ? this.translate.instant(translations[headerList[index]]) + DELIMITER
        : headerList[index] + DELIMITER;
    }

    headerRow = headerRow.slice(0, -1);
    csvOutput += headerRow + '\r\n';
    for (let i = 0; i < jsonInput.length; i++) {
      let contentLine = '';
      for (let index in headerList) {
        let head = headerList[index];
        if (index == '0') {
          contentLine += (jsonInput[i][head] ?? "");
        } else {
          contentLine += DELIMITER + (jsonInput[i][head] ?? "");
        }
      }
      csvOutput += contentLine + '\r\n';
    }
    return csvOutput;
  }
  //  ReportMetaData
  downloadFile({
    data,
    headerList,
    filename,
    formatType,
    metaData,
    translations,
  }: DownloadInput) {
    metaData = metaData || null;
    translations = translations || null;

    if (formatType == 'CSV') {
      let csvData = this.convertToCSV({
        objArray: data,
        headerList,
        metaData,
        translations,
      });
      let blob = new Blob(['\ufeff' + csvData], {
        type: 'text/csv;charset=utf-8;',
      });
      let dwldLink = document.createElement('a');
      let url = URL.createObjectURL(blob);
      dwldLink.setAttribute('href', url);
      dwldLink.setAttribute('download', filename + '.csv');
      dwldLink.style.visibility = 'hidden';
      document.body.appendChild(dwldLink);
      dwldLink.click();
      document.body.removeChild(dwldLink);
      this._isDownloading.next(true);
    } else if (formatType == 'PDF') {
      var doc = new jsPDF({ orientation: 'landscape' });
      if (metaData) {
        doc.setFontSize(8);
        let line: number = 15;
        for (let [metaTitle, metaValue] of Object.entries(metaData)) {
          if (metaValue) {
            metaTitle = this.translate.instant(translations?.['metaTranslation']?.['title']?.[metaTitle] || metaTitle);
            metaValue = this.translate.instant(translations?.['metaTranslation']?.['title']?.[metaValue] || metaValue);
            doc.text(`${metaTitle}: ${metaValue}`, 15, (line += 5))
          };
        }

      }

      var col = headerList.map((header: string) => {
        return translations?.[header]
          ? this.translate.instant(translations[header])
          : header;
      });
      var rows = [];
      var contentBody = typeof data != 'object' ? JSON.parse(data) : data;

      for (let i = 0; i < contentBody.length; i++) {
        let contentLine = [];
        for (let index in headerList) {
          let head = headerList[index];
          let content = this.checkForCurrency(head, contentBody[i][head] ?? '');

          contentLine.push(content);
        }
        rows.push(contentLine);
      }
      autoTable(doc, {
        head: [col],
        body: rows,
        theme: 'grid',
        margin: { top: 60 },
        styles: {
          overflow: 'linebreak',
          cellWidth: 'auto',
          minCellWidth: 14,
          fontSize: 7,
        },
      });
      doc.save(filename + '.pdf');
      this._isDownloading.next(true);
    } else if (formatType == 'XLSX') {



      this.generateExcelFile({
        data,
        headerList,
        filename,
        formatType,
        metaData,
        translations
      });
    }
  }

  getDownloadStatus() {
    return this._isDownloading.asObservable();
  }



  generateExcelFile({
    data,
    headerList,
    filename,
    formatType,
    metaData,
    translations,
  }: DownloadInput) {
    if (metaData) {
      for (let key in metaData)
        if (!metaData?.[key]) delete metaData[key];
    }

    const rowMargin: number = 3;
    let headerRowOrigin: number = Object.keys(metaData).length;
    headerRowOrigin += (Object.keys(metaData).length ? rowMargin : 0);

    if (headerList && headerList.length) {
      headerList = headerList.map((header: string) => this.translate.instant(translations[header] || header))
    }
    let worksheet: WorkSheet = utils.json_to_sheet([]);
    // set meta data
    Object.entries(metaData).forEach(([metaTitle, metaValue], index) => {
      metaTitle = this.translate.instant(translations?.['metaTranslation']?.['title']?.[metaTitle] || metaTitle);
      metaValue = this.translate.instant(translations?.['metaTranslation']?.['value']?.[metaValue] || metaValue);
      utils.sheet_add_aoa(worksheet, [[metaTitle, metaValue]], { origin: { c: 0, r: index } });
    })
    // headers
    utils.sheet_add_aoa(worksheet, [headerList], { origin: { c: 0, r: headerRowOrigin } });
    // content
    const content: string[][] = data.reduce((content: string[][], row: any, index: number) => {
      content.push(Object.values(row));
      return content;
    }, [])
    utils.sheet_add_aoa(worksheet, content, { origin: { c: 0, r: headerRowOrigin + 1 } });
    // create and download xlsx file
    const workbook: WorkBook = { Sheets: { 'data': worksheet }, SheetNames: ['data'] };
    const excelBuffer: any = write(workbook, { bookType: 'xlsx', type: 'array' });
    this.saveAsExcelFile(excelBuffer, filename);
  }

  saveAsExcelFile(buffer: any, fileName: string) {
    const data: Blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });
    FileSaver.saveAs(data, fileName + '_' + new Date().getTime() + '.xlsx');
  }

  private checkForCurrency(header: string, value: number | string): string | number {
    if (/cost|price/gmi.test(header)) {
      return frenchNumber(value);
    }
    return value;
  }
}
